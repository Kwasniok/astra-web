import glob
import os
from shutil import rmtree

from astra_web.filter import filter_has_prefix
from astra_web.file import find_symlinks, read_json, read_txt, write_json, write_txt
from astra_web.actor import Actor
from astra_web.status import DispatchStatus
from astra_web.uuid import get_uuid

from .schemas.io import (
    GeneratorData,
    GeneratorMeta,
    GeneratorDispatchOutput,
    GeneratorInput,
    GeneratorOutput,
)
from .schemas.particles import Particles


async def dispatch_particle_distribution_generation(
    generator_input: GeneratorInput,
    local_actor: Actor,
    host_actor: Actor,
) -> GeneratorDispatchOutput:
    """Dispatches the generation of a particle distribution based on the provided generator input.
    The generator input is written to disk, and the generation is dispatched to the appropriate host.
    """
    # local
    _write_generator_files(generator_input, local_actor)
    # 'remote'
    response = await host_actor.dispatch_generation(
        generator_input,
    )
    return GeneratorDispatchOutput(
        gen_id=generator_input.id,
        dispatch_response=response,
    )


async def redispatch_particle_distribution_generation(
    gen_id: str,
    actor: Actor,
) -> GeneratorDispatchOutput:
    """
    Redispatches the generation of a particle distribution based on an existing generator ID.

    The existing generator input is loaded from disk, and the generation is dispatched to the appropriate host.

    Raises:
        FileNotFoundError: If the generator input does not exist.
    """

    _reset_generator(gen_id, actor)

    generator_input = load_generator_input(gen_id, actor)
    if generator_input is None:
        raise FileNotFoundError(f"Generator input for ID {gen_id} not found.")

    response = await actor.dispatch_generation(
        generator_input,
    )
    return GeneratorDispatchOutput(
        gen_id=gen_id,
        dispatch_response=response,
    )


def _write_generator_files(generator_input: GeneratorInput, actor: Actor) -> None:
    path = actor.generator_path(generator_input.id)
    os.makedirs(path, exist_ok=True)
    write_json(generator_input, actor.generator_path(generator_input.id, "input.json"))
    write_txt(
        generator_input.to_ini(),
        actor.generator_path(generator_input.id, "generator.in"),
    )


def _reset_generator(
    gen_id: str,
    actor: Actor,
) -> None:
    """
    Clears ALL generator files and rewrites the initially required files.

    Raises:
        FileNotFoundError: If no generator input for the given ID is found.
    """

    input = load_generator_input(gen_id, actor)
    if input is None:
        raise FileNotFoundError(f"Generator input for ID {gen_id} not found.")

    delete_particle_distribution(gen_id, actor)
    _write_generator_files(input, actor)


def load_generator_data(
    gen_id: str,
    actor: Actor,
    include: list[str] | None = None,
) -> GeneratorData | None:
    """
    Loads the generator output for a given generator ID.
    Returns None if the particle distribution does not exist.


    Parameters:
        include: Optional list of feature paths to include. All others are excluded. If `None`, all features are included.
            Example: `["input.run", "output"]`

    """
    if not os.path.exists(actor.generator_path(gen_id, "distribution.ini")):
        return None

    input = (
        load_generator_input(gen_id, actor)
        if filter_has_prefix(include, "input")
        else None
    )

    output = (
        _load_output(gen_id, actor) if filter_has_prefix(include, "output") else None
    )

    astra_input = (
        _load_generator_input(gen_id, actor)
        if filter_has_prefix(include, "astra_input")
        else None
    )

    astra_output = (
        _load_generator_output(gen_id, actor)
        if filter_has_prefix(include, "astra_output")
        else None
    )

    meta = _load_meta(gen_id, actor) if filter_has_prefix(include, "meta") else None

    return GeneratorData(
        input=input,
        output=output,
        astra_input=astra_input,
        astra_output=astra_output,
        meta=meta,
    )


def load_generator_input(gen_id: str, actor: Actor) -> GeneratorInput | None:
    """
    Loads the generator input for a given generator ID.
    """
    input_path = actor.generator_path(gen_id, "input.json")
    if os.path.exists(input_path):
        input = read_json(GeneratorInput, input_path)
        input._id = gen_id
        return input
    return None


def _load_output(gen_id: str, actor: Actor) -> GeneratorOutput | None:
    return GeneratorOutput(particles=_load_particle_file(gen_id, actor))


def _load_particle_file(gen_id: str, actor: Actor) -> Particles:
    """
    Reads the particle file generated by the ASTRA generator."""
    path = actor.generator_path(gen_id, "distribution.ini")

    return Particles.read_from_csv(path)


def _load_generator_input(gen_id: str, actor: Actor) -> str | None:
    astra_input_path = actor.generator_path(gen_id, "generator.in")
    if os.path.exists(astra_input_path):
        return read_txt(astra_input_path)
    return None


def _load_generator_output(gen_id: str, actor: Actor) -> str | None:
    astra_output_path = actor.generator_path(gen_id, "generator.out")
    if os.path.exists(astra_output_path):
        return read_txt(astra_output_path)
    return None


def _load_meta(gen_id: str, actor: Actor) -> GeneratorMeta | None:
    meta_path = actor.generator_path(gen_id, "meta.json")
    if os.path.exists(meta_path):
        return read_json(GeneratorMeta, meta_path)
    return None


def list_generator_ids(
    actor: Actor,
    state: DispatchStatus | None = None,
) -> list[str]:
    """
    Lists IDs of particle distribution generations.
    """

    ids_all = map(
        lambda p: os.path.basename(p),
        glob.glob(actor.generator_path("*")),
    )

    if state is None:
        return sorted(ids_all)
    else:
        return sorted(id for id in ids_all if get_generation_status(id, actor) == state)


def list_particle_distribution_states(
    actor: Actor,
    gen_ids: list[str] | None = None,
) -> list[tuple[str, DispatchStatus]]:
    """
    Returns the current state of the particle distributions.
    """
    if gen_ids is None:
        gen_ids = list_generator_ids(actor)
    return list((gen_id, get_generation_status(gen_id, actor)) for gen_id in gen_ids)


def delete_particle_distribution(
    gen_id: str,
    actor: Actor,
    force: bool = False,
) -> list[str] | None:
    """
    Deletes the particle distribution file for a given generator ID.

    Returns a list of symlinks that are referencing the distribution file and blocking the deletion when not forced. Otherwise, returns None.
    """
    path = actor.generator_path(gen_id)
    if not os.path.exists(path):
        return

    if not force:
        # delete only when nothing is referencing it
        links = find_symlinks(
            actor.generator_path(gen_id, "distribution.ini"),
            actor.data_path(),
            link_name="distribution.ini",
        )
        if len(links) > 0:
            return links
        # now its safe to remove

    rmtree(path)
    return


def write_particle_distribution(
    particles: Particles, actor: Actor, comment: str | None = None
) -> str:
    """
    Writes the particle distribution to disk.
    """
    gen_id = get_uuid()
    dist_path = actor.generator_path(gen_id, "distribution.ini")

    if os.path.exists(dist_path):
        raise RuntimeError("Generated ID already exists.")
    os.makedirs(os.path.dirname(dist_path), exist_ok=True)

    particles.write_to_csv(dist_path)

    meta = GeneratorMeta(comment=comment)
    meta_path = actor.generator_path(gen_id, "meta.json")
    write_json(meta, path=meta_path)

    return gen_id


def get_generation_status(ge_id: str, actor: Actor) -> DispatchStatus:
    """
    Returns status of the particle generation.
    """
    path = actor.generator_path(ge_id, "generator.err")
    if os.path.isfile(path) and os.path.getsize(path) > 0:
        return DispatchStatus.FAILED
    path = actor.generator_path(ge_id, "generator.out")
    if os.path.isfile(path):
        if "phase-space distribution saved to file" in read_txt(path):
            return DispatchStatus.FINISHED
    return DispatchStatus.UNFINISHED
