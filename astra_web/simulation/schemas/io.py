import numpy as np
from typing import Optional
from pydantic import BaseModel, ConfigDict, Field
from astra_web.generator.schemas.particles import Particles
from astra_web.host_localizer.schemas.dispatch import DispatchResponse
from astra_web.uuid import get_uuid
from astra_web.file import IniExportableModel
from .run import SimulationRunSpecifications
from .modules import Solenoid, Cavity
from .space_charge import SpaceCharge
from .tables import XYEmittanceTable, ZEmittanceTable


class SimulationOutputSpecification(IniExportableModel):
    model_config = ConfigDict(extra="forbid")

    z_start: float = Field(
        default=0.0,
        alias="ZSTART",
        validation_alias="z_start",
        description="Minimal z position for the generation of output.",
        json_schema_extra={"format": "Unit: [m]"},
    )
    z_stop: float = Field(
        default=1.0,
        alias="ZSTOP",
        validation_alias="z_stop",
        description="Longitudinal stop position. Tracking will stop when the bunch center passes z_stop.",
        json_schema_extra={"format": "Unit: [m]"},
    )
    emittance_checkpoint_num: int = Field(
        default=100,
        alias="Zemit",
        validation_alias="emittance_checkpoint_num",
        description="The interval z_stop - z_start is divided into z_emit sub-intervals. At the end of \
                     each sub-interval statistical bunch parameters such as emittance are saved. It is advised to set \
                     a multiple of z_phase as value.",
        gt=1,
    )
    distribution_checkpoint_num: int = Field(
        default=1,
        alias="Zphase",
        validation_alias="distribution_checkpoint_num",
        description="The interval z_stop - z_start is divided into z_emit sub-intervals. At the end of \
                     each sub-interval a complete particle distribution is saved.",
    )
    high_resolution: bool = Field(
        default=True,
        alias="High_res",
        validation_alias="high_resolution",
        description="If true, particle distributions are saved with increased accuracy",
    )
    high_accuracy: bool = Field(
        default=True,
        alias="RefS",
        validation_alias="high_accuracy",
        description="If true, ASTRA generates output of the off-axis reference trajectory, energy gain etc. at each \
                     Runge-Kutta time step.",
    )
    generate_emittance_output: bool = Field(
        default=True,
        alias="EmitS",
        validation_alias="generate_emittance_output",
        description="If true, output of the beam emittance and other statistical beam parameters is generated. The parameters \
                    are calculated and stored at the end of each sub-interval defined by z_emit.",
    )
    generate_ts_emittance_output: bool = Field(
        default=True,
        alias="Tr_emitS",
        validation_alias="generate_ts_emittance_output",
        description="If true, output of the trace space beam emittance and other statistical beam parameters is \
                    generated. The parameters are calculated and stored at the end of each sub-interval defined by z_emit.",
    )
    generate_complete_particle_output: bool = Field(
        default=True,
        alias="PhaseS",
        validation_alias="generate_complete_particle_output",
        description="If true, the complete particle distribution is saved at z_phase different locations.",
    )

    def to_ini(self) -> str:
        return "&OUTPUT" + self._to_ini() + "/"


class SimulationInput(IniExportableModel):
    model_config = ConfigDict(extra="forbid")

    _sim_id: str

    @property
    def sim_id(self):
        return self._sim_id

    @property
    def run_dir(self) -> str:
        return self.sim_id

    run_specs: SimulationRunSpecifications = Field(
        default=SimulationRunSpecifications(),
        description="Specifications of operative run parameters such as thread numbers, run directories and more.",
    )
    output_specs: SimulationOutputSpecification = Field(
        default=SimulationOutputSpecification(),
        description="Specifications about the output files generated by the simulation.",
    )
    cavities: list[Cavity] = Field(
        default=[],
        description="Specifications of cavities existing in the simulation setup. If not specified differently, \
            cavities will be ordered w.r.t. to the z_0 parameter values.",
    )
    solenoids: list[Solenoid] = Field(
        default=[],
        description="Specifications of solenoids existing in the simulation setup. If not specified differently, \
            solenoids will be ordered w.r.t. to the z_0 parameter values.",
    )
    space_charge: SpaceCharge = Field(default=SpaceCharge(), description="")

    def _sort_and_set_ids(self, attribute_key: str) -> None:
        attr = getattr(self, attribute_key)
        if not np.any(list(map(lambda o: o.z_0 is None, attr))):
            setattr(self, attribute_key, sorted(attr, key=lambda element: element.z_0))
        for idx, element in enumerate(getattr(self, attribute_key), start=1):
            element.id = idx

    def model_post_init(self, __context) -> None:
        self._sim_id = get_uuid()
        self._sort_and_set_ids("cavities")
        self._sort_and_set_ids("solenoids")

    def to_ini(self) -> str:
        has_cavities = str(len(self.cavities) > 0).lower()
        has_solenoids = str(len(self.solenoids) > 0).lower()
        cavity_str = f"&CAVITY\n    LEfield = {has_cavities}\n{''.join([c.to_ini() for c in self.cavities])}/"
        solenoid_str = f"&SOLENOID\n    LBfield = {has_solenoids}\n{''.join([s.to_ini() for s in self.solenoids])}/"
        run_str = self.run_specs.to_ini()
        charge_str = self.space_charge.to_ini()
        output_str = self.output_specs.to_ini()

        return (
            "\n\n".join([run_str, output_str, charge_str, cavity_str, solenoid_str])
            + "\n"
        )


class SimulationDispatchOutput(BaseModel):
    model_config = ConfigDict(extra="forbid")

    sim_id: str
    dispatch_response: DispatchResponse


class SimulationData(BaseModel):
    model_config = ConfigDict(extra="forbid")

    particles: Optional[list[Particles]] = Field(default=[Particles()])
    emittance_x: Optional[XYEmittanceTable] = Field(
        default=None,
    )
    emittance_y: Optional[XYEmittanceTable] = Field(
        default=None,
    )
    emittance_z: Optional[ZEmittanceTable] = Field(default=None)


class SimulationAllData(BaseModel):
    model_config = ConfigDict(extra="forbid")

    web_input: SimulationInput
    data: SimulationData | None = Field(
        default=None,
        description="Simulation data, if the simulation has finished successfully.",
    )
    run_input: str
    run_output: str


class StatisticsInput(BaseModel):
    model_config = ConfigDict(extra="forbid")

    pass


class StatisticsOutput(BaseModel):
    model_config = ConfigDict(extra="forbid")

    sim_id: str
    particle_counts: dict = Field(
        description="Number of particles - active, inactive, total."
    )
